<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SCEnergy 태양광 채굴기</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
  <style>
    html, body {height:100%; margin:0;}
    #map {height:100%; width:100%;}
  </style>
</head>
<body class="bg-slate-900 text-slate-100">
  <!-- Login overlay -->
  <div id="loginOverlay" class="fixed inset-0 bg-black/70 flex items-center justify-center z-[9999] hidden">
    <div class="bg-slate-800 border border-slate-700 rounded-xl p-6 w-[360px]">
      <div class="text-lg font-bold mb-4">로그인</div>
      <div class="space-y-2">
        <input id="loginId" class="w-full px-3 py-2 rounded bg-slate-900 border border-slate-700" placeholder="아이디"/>
        <input id="loginPw" type="password" class="w-full px-3 py-2 rounded bg-slate-900 border border-slate-700" placeholder="비밀번호"/>
        <button id="loginBtn" class="w-full py-2 rounded bg-indigo-600 hover:bg-indigo-500 font-bold">로그인</button>
        <div id="loginErr" class="text-xs text-rose-300"></div>
      </div>
    </div>
  </div>

  <!-- Sidebar -->
  <div class="fixed top-3 left-3 z-[1000] w-[360px] max-h-[95vh] overflow-auto rounded-xl bg-slate-800/95 border border-slate-700 shadow-xl">
    <div class="p-3 border-b border-slate-700 flex items-center justify-between">
      <div class="font-extrabold">SCEnergy</div>
      <div class="text-xs flex items-center gap-2">
        <span id="meBadge" class="px-2 py-1 rounded bg-slate-700">guest</span>
        <button id="logoutBtn" class="px-2 py-1 rounded bg-slate-700 hover:bg-slate-600 hidden">로그아웃</button>
      </div>
    </div>

    <div class="p-3 space-y-3">
      <div class="bg-slate-900/60 rounded-lg p-3 border border-slate-700">
        <div class="text-sm font-bold mb-2">주소 검색</div>
        <div class="flex gap-2">
          <input id="addrInput" class="flex-1 px-3 py-2 rounded bg-slate-900 border border-slate-700" placeholder="예) 서울특별시 강남구 ..."/>
          <button id="addrGo" class="px-3 py-2 rounded bg-cyan-600 hover:bg-cyan-500 font-bold">이동</button>
        </div>
        <div class="text-[11px] text-slate-300 mt-2">지도를 이동/확대 후 자동 스캔을 실행하세요.</div>
      </div>

      <div class="bg-slate-900/60 rounded-lg p-3 border border-slate-700">
        <div class="flex items-center justify-between mb-2">
          <div class="text-sm font-bold">자동 스캔</div>
          <label class="text-xs flex items-center gap-2">
            <input id="autoFollow" type="checkbox" class="accent-indigo-500" checked/>
            지도 자동 따라가기
          </label>
        </div>

        <div class="grid grid-cols-2 gap-2">
          <div>
            <div class="text-xs text-slate-300 mb-1">스텝 지연(ms)</div>
            <select id="scanDelay" class="w-full px-2 py-2 rounded bg-slate-800 border border-slate-700 text-sm">
              <option value="3000">3,000</option>
              <option value="6000" selected>6,000 (권장)</option>
              <option value="10000">10,000</option>
            </select>
          </div>
          <div>
            <div class="text-xs text-slate-300 mb-1">타이머</div>
            <div id="timerRemaining" class="w-full px-2 py-2 rounded bg-slate-800 border border-slate-700 font-mono text-sm">00:00:00</div>
          </div>
        </div>

        <div class="mt-3">
          <div class="flex justify-between text-xs text-slate-300">
            <div id="progressText">0 / 20</div>
            <div id="foundCount" class="text-cyan-300 font-bold">검색된 구역: 0개</div>
          </div>
          <div class="w-full bg-slate-700 rounded-full h-2 mt-2">
            <div id="progressBar" class="h-2 rounded-full bg-indigo-500" style="width:0%"></div>
          </div>
        </div>

        <div class="grid grid-cols-2 gap-2 mt-3">
          <button id="missionToggleBtn" class="py-2 rounded bg-emerald-600 hover:bg-emerald-500 font-bold text-sm">▶ 시작</button>
          <button id="missionCancelBtn" class="py-2 rounded bg-rose-600 hover:bg-rose-500 font-bold text-sm">■ 취소(진행리셋)</button>
          <button id="missionResetBtn" class="py-2 rounded bg-slate-700 hover:bg-slate-600 font-bold text-sm col-span-2">🔄 전체 리셋(결과삭제)</button>
        </div>

        <div class="grid grid-cols-2 gap-2 mt-2">
          <button id="dlGeoBtn" class="py-2 rounded bg-slate-700 hover:bg-slate-600 font-bold text-sm">⬇ GeoJSON</button>
          <button id="dlCsvBtn" class="py-2 rounded bg-slate-700 hover:bg-slate-600 font-bold text-sm">⬇ CSV</button>
        </div>

        <div class="text-[11px] text-slate-300 mt-2">
          • 시작 버튼: 시작/일시정지/재개 토글<br/>
          • 취소: 진행률만 리셋(지금까지 결과는 유지)<br/>
          • 전체 리셋: 결과까지 전부 삭제
        </div>
      </div>

      <div class="bg-slate-900/60 rounded-lg p-3 border border-slate-700">
        <div class="text-sm font-bold mb-2">정밀 분석</div>
        <div class="text-xs text-slate-300 mb-2">지도에서 지붕/토지 폴리곤을 클릭하면 분석 데이터가 생성됩니다.</div>

        <div class="grid grid-cols-2 gap-2">
          <button id="openReportBtn" class="py-2 rounded bg-indigo-600 hover:bg-indigo-500 font-bold text-sm">상세보기(리포트)</button>
          <button id="clearPanelsBtn" class="py-2 rounded bg-slate-700 hover:bg-slate-600 font-bold text-sm">패널/선택 초기화</button>
        </div>

        <!-- hidden form for report -->
        <form id="reportForm" action="/report" method="POST" target="_blank" class="hidden">
          <input type="hidden" name="analysisData" id="analysisDataInput"/>
          <input type="hidden" name="address" id="reportAddrInput"/>
          <input type="hidden" name="date" id="reportDateInput"/>
        </form>

        <div id="analysisMini" class="mt-3 text-xs text-slate-200 whitespace-pre-wrap"></div>
      </div>
    </div>
  </div>

  <div id="map"></div>

<script>
(() => {
  const BACKEND_URL = window.location.origin;

  // -----------------------------
  // Login
  // -----------------------------
  const loginOverlay = document.getElementById('loginOverlay');
  const meBadge = document.getElementById('meBadge');
  const logoutBtn = document.getElementById('logoutBtn');

  async function refreshMe() {
    const res = await fetch(`${BACKEND_URL}/api/auth/me`, {credentials:'include'});
    const j = await res.json().catch(()=>({ok:false}));
    if (j.ok && j.logged_in) {
      meBadge.textContent = `${j.id} (${j.role})`;
      logoutBtn.classList.remove('hidden');
      loginOverlay.classList.add('hidden');
      return true;
    }
    meBadge.textContent = 'guest';
    logoutBtn.classList.add('hidden');
    loginOverlay.classList.remove('hidden');
    return false;
  }

  document.getElementById('loginBtn').onclick = async () => {
    const id = document.getElementById('loginId').value.trim();
    const pw = document.getElementById('loginPw').value;
    const err = document.getElementById('loginErr');
    err.textContent = '';
    const res = await fetch(`${BACKEND_URL}/api/auth/login`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      credentials:'include',
      body: JSON.stringify({id, pw})
    });
    const j = await res.json().catch(()=>({ok:false, error:'network'}));
    if (!j.ok) {
      err.textContent = '로그인 실패: ' + (j.error || res.status);
      return;
    }
    await refreshMe();
  };

  logoutBtn.onclick = async () => {
    await fetch(`${BACKEND_URL}/api/auth/logout`, {method:'POST', credentials:'include'});
    await refreshMe();
  };

  // -----------------------------
  // Map
  // -----------------------------
  const map = L.map('map', {zoomControl:true}).setView([37.5665, 126.9780], 13);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom: 20}).addTo(map);

  const resultsLayer = L.geoJSON([], {
    style: (f) => {
      const t = f.properties?.type || 'roof';
      if (t === 'land') {
        return {weight:2, color:'#a16207', fillOpacity:0.05}; // brown border
      }
      return {weight:2, color:'#22c55e', fillOpacity:0.05}; // green border
    },
    onEachFeature: (feature, layer) => {
      layer.on('click', () => onSelectFeature(feature, layer));
    }
  }).addTo(map);

  // Panels layer: always blue, roof/land same.
  const panelsLayer = L.geoJSON([], {
    style: {weight:1, color:'#2563eb', fillColor:'#2563eb', fillOpacity:0.35}
  }).addTo(map);

  let currentAnalysisData = null;
  function setMini(text) {
    document.getElementById('analysisMini').textContent = text || '';
  }

  function onSelectFeature(feature, layer) {
    const props = feature.properties || {};
    const address = props.address || props.name || '(선택된 영역)';
    const area = props.area_m2 || props.area || 0;

    // create panels visualization (dummy: offset polygon)
    panelsLayer.clearLayers();
    try {
      const poly = feature.geometry;
      // simple generate a smaller polygon as "panel area" using turf.buffer negative is tricky; use centroid + scale
      const c = turf.centroid(poly);
      const scaled = turf.transformScale(poly, 0.85, {origin: c});
      panelsLayer.addData(scaled);
    } catch (e) {
      // ignore
    }

    // minimal finance
    const acCapacity = Math.max(0, Number(area) * 0.15 / 1000); // rough: 0.15kW per m2 -> MW? adjust to kW
    const finance = {
      acCapacity: Number(acCapacity.toFixed(2)),
      capacity: Number(acCapacity.toFixed(2)),
      estMonthlyKwh: Math.round(acCapacity * 120),
    };

    currentAnalysisData = {
      address,
      date: new Date().toISOString().slice(0,10),
      finance,
      feature: feature,
      ai_score: {score: 78, grade: "B", risk_flags:["계통여유 확인 필요"]},
      env_assessment: {note:"상세 확인 필요"}
    };

    setMini(`선택: ${address}\n면적(m²): ${area}\n예상 용량(kW): ${finance.capacity}`);
  }

  // Address move (Nominatim)
  document.getElementById('addrGo').onclick = async () => {
    const q = document.getElementById('addrInput').value.trim();
    if (!q) return;
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`;
    const res = await fetch(url);
    const j = await res.json().catch(()=>[]);
    if (j && j[0]) {
      map.setView([Number(j[0].lat), Number(j[0].lon)], 17);
    }
  };

  // -----------------------------
  // Mission scan
  // -----------------------------
  const missionToggleBtn = document.getElementById('missionToggleBtn');
  const missionCancelBtn = document.getElementById('missionCancelBtn');
  const missionResetBtn  = document.getElementById('missionResetBtn');
  const progressText = document.getElementById('progressText');
  const progressBar = document.getElementById('progressBar');
  const foundCount = document.getElementById('foundCount');
  const timerRemaining = document.getElementById('timerRemaining');

  let missionState = 'idle'; // idle | running | paused
  let missionIdx = 0;
  let missionTotal = 20;
  let missionTimer = null;
  let countdownTimer = null;
  let missionEndAt = null;

  const scanResults = []; // features
  const scanResultIds = new Set();

  function fmtHHMMSS(ms) {
    ms = Math.max(0, ms);
    const s = Math.floor(ms/1000);
    const hh = String(Math.floor(s/3600)).padStart(2,'0');
    const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${hh}:${mm}:${ss}`;
  }

  function updateMissionUI() {
    progressText.textContent = `${missionIdx} / ${missionTotal}`;
    progressBar.style.width = `${(missionTotal ? (missionIdx/missionTotal)*100 : 0)}%`;
    foundCount.textContent = `검색된 구역: ${scanResultIds.size}개`;
  }

  function startCountdown() {
    if (countdownTimer) clearInterval(countdownTimer);
    countdownTimer = setInterval(() => {
      if (!missionEndAt) return;
      const ms = missionEndAt - Date.now();
      timerRemaining.textContent = fmtHHMMSS(ms);
      if (ms <= 0) {
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
    }, 250);
  }

  function buildGridCells() {
    // Build 4x5 grid over current map bounds
    const b = map.getBounds();
    const south = b.getSouth(), north = b.getNorth();
    const west = b.getWest(), east = b.getEast();
    const rows = 4, cols = 5;
    const cells = [];
    for (let r=0; r<rows; r++) {
      for (let c=0; c<cols; c++) {
        const lat1 = south + (north-south) * (r/rows);
        const lat2 = south + (north-south) * ((r+1)/rows);
        const lng1 = west + (east-west) * (c/cols);
        const lng2 = west + (east-west) * ((c+1)/cols);
        const center = [(lat1+lat2)/2, (lng1+lng2)/2];
        const poly = turf.polygon([[
          [lng1, lat1],[lng2, lat1],[lng2, lat2],[lng1, lat2],[lng1, lat1]
        ]], {cellIndex: cells.length});
        cells.push({center, poly});
      }
    }
    return cells.slice(0, missionTotal);
  }

  let missionCells = [];

  function generateFakeResults(cellPoly, n=1) {
    // For demo: create 0~2 random polygons inside the cell
    const out = [];
    const count = Math.floor(Math.random()*3); // 0,1,2
    for (let i=0;i<count;i++) {
      const pt = turf.randomPoint(1, {bbox: turf.bbox(cellPoly)}).features[0];
      const size = 0.00015 + Math.random()*0.0002;
      const bbox = turf.bbox(pt);
      const lng = pt.geometry.coordinates[0];
      const lat = pt.geometry.coordinates[1];
      const poly = turf.polygon([[
        [lng-size, lat-size],[lng+size, lat-size],[lng+size, lat+size],[lng-size, lat+size],[lng-size, lat-size]
      ]]);
      const type = (Math.random() < 0.3) ? 'land' : 'roof';
      const id = `${type}-${lng.toFixed(5)}-${lat.toFixed(5)}`;
      poly.properties = { id, type, area_m2: Math.round(500 + Math.random()*1500), address: `스캔결과(${type}) ${id}` };
      out.push(poly);
    }
    return out;
  }

  async function missionStep() {
    if (missionState !== 'running') return;
    if (missionIdx >= missionTotal) {
      stopMission(true);
      return;
    }
    const cell = missionCells[missionIdx];
    missionIdx += 1;
    updateMissionUI();

    if (document.getElementById('autoFollow').checked) {
      map.setView(cell.center, Math.max(map.getZoom(), 18), {animate:true});
    }

    // "scan": here you would call your real scan API.
    // We generate demo results and accumulate them.
    const features = generateFakeResults(cell.poly);
    for (const f of features) {
      const id = f.properties?.id;
      if (id && !scanResultIds.has(id)) {
        scanResultIds.add(id);
        scanResults.push(f);
        resultsLayer.addData(f);
      }
    }
    updateMissionUI();

    const delay = Number(document.getElementById('scanDelay').value || 6000);
    missionTimer = setTimeout(missionStep, delay);
  }

  function startMission() {
    if (missionState === 'running') return;
    if (missionState === 'idle') {
      missionIdx = 0;
      missionCells = buildGridCells();
      const delay = Number(document.getElementById('scanDelay').value || 6000);
      missionEndAt = Date.now() + delay * missionTotal;
      startCountdown();
    }
    missionState = 'running';
    missionToggleBtn.textContent = '⏸ 일시정지';
    missionStep();
  }

  function pauseMission() {
    if (missionState !== 'running') return;
    missionState = 'paused';
    missionToggleBtn.textContent = '▶ 재개';
    if (missionTimer) { clearTimeout(missionTimer); missionTimer = null; }
    // countdown freezes naturally because missionEndAt is fixed;
    // simple: stop countdown during pause
    if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }
  }

  function stopMission(finished=false) {
    missionState = 'idle';
    missionToggleBtn.textContent = '▶ 시작';
    if (missionTimer) { clearTimeout(missionTimer); missionTimer = null; }
    if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }
    missionEndAt = null;
    timerRemaining.textContent = finished ? '00:00:00' : timerRemaining.textContent;
  }

  missionToggleBtn.onclick = () => {
    if (missionState === 'running') pauseMission();
    else startMission();
  };

  missionCancelBtn.onclick = () => {
    // cancel: stop running and reset progress only (keep results)
    stopMission(false);
    missionIdx = 0;
    updateMissionUI();
    timerRemaining.textContent = '00:00:00';
  };

  missionResetBtn.onclick = () => {
    // full reset: clear results and counters
    stopMission(false);
    missionIdx = 0;
    scanResults.length = 0;
    scanResultIds.clear();
    resultsLayer.clearLayers();
    panelsLayer.clearLayers();
    currentAnalysisData = null;
    setMini('');
    updateMissionUI();
    timerRemaining.textContent = '00:00:00';
  };

  function download(filename, content, mime) {
    const blob = new Blob([content], {type: mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  document.getElementById('dlGeoBtn').onclick = () => {
    const fc = turf.featureCollection(scanResults);
    download('scan_results.geojson', JSON.stringify(fc, null, 2), 'application/geo+json');
  };

  document.getElementById('dlCsvBtn').onclick = () => {
    const rows = [['id','type','area_m2','address','lon','lat']];
    for (const f of scanResults) {
      const p = f.properties || {};
      const c = turf.centroid(f).geometry.coordinates;
      rows.push([p.id||'', p.type||'', p.area_m2||'', (p.address||'').replaceAll(',',' '), c[0], c[1]]);
    }
    const csv = rows.map(r => r.map(v => `"${String(v).replaceAll('"','""')}"`).join(',')).join('\n');
    download('scan_results.csv', csv, 'text/csv');
  };

  // -----------------------------
  // Report
  // -----------------------------
  document.getElementById('openReportBtn').onclick = async () => {
    if (!currentAnalysisData) {
      alert('먼저 지도에서 지붕/토지를 클릭해 분석 대상을 선택하세요.');
      return;
    }
    // Optional: call backend comprehensive analysis to enrich
    try {
      const res = await fetch(`${BACKEND_URL}/api/analyze/comprehensive`, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        credentials:'include',
        body: JSON.stringify(currentAnalysisData)
      });
      const j = await res.json().catch(()=>null);
      if (j && j.ok) currentAnalysisData = j;
    } catch (e) {}

    document.getElementById('analysisDataInput').value = JSON.stringify(currentAnalysisData);
    document.getElementById('reportAddrInput').value = currentAnalysisData.address || '';
    document.getElementById('reportDateInput').value = currentAnalysisData.date || '';
    document.getElementById('reportForm').submit();
  };

  document.getElementById('clearPanelsBtn').onclick = () => {
    panelsLayer.clearLayers();
    currentAnalysisData = null;
    setMini('');
  };

  // init
  updateMissionUI();
  refreshMe();
})();
</script>
</body>
</html>
